План вхождения в backend разработку

Один мой друг с инженерным образованием спросил недавно, с чего начать изучение программирования с нуля и сразу начал узнавать за многочисленные курсы.
В них у меня опыта нет, за исключением сухих официальных сертификаций за авторством IBM и Red Hat.
Расписал по памяти собственный путь, который, разумеется, очень личный.

**Интересно, насколько его сокращают курсы и сколько это все займет через них.**

##### Этап 1 - Войти в IT
- Читаешь любую популярную книгу по интересующему языку (в моем случае это “Философия Java” Брюса Эккеля). Учишь классическое императивное программирование - функции, базовые типы данных, циклы, ветвление (if/else), рекурсию, парсинг ввода из терминала, форматирование вывода. Переходишь к структурам данных (массивы, стек, очередь, связанные списки, описание графов на списках и матрицах связности). При наличии управления памятью в языке (C и Go, например), учишь работу с указателями (передача аргументов по ссылке/по значению).
- Практикуешься на математических задачах (например, ACMP), параллельно привыкая к синтаксису, учишься пользоваться IDE и дебагом.
- Читаешь книгу далее, учишь ООП (полиморфизм, инкапсуляция, наследование), пробуешь работу с классами и методами.
- Делаешь задачи на работу с классами и методами (наследование в первую очередь, дженерики и параметризация во вторую). Конструкторы, getter/setter, скрытие реализации (приватные и публичные поля и методы).
- Читаешь книгу далее, учишь реализацию коллекций в языке (списки, хэш-таблицы, множества). Читаешь исходный код интерфейсов коллекций, читаешь исходный код имплементаций этих интерфейсов из стандартной библиотеки (для Java это List, Map, Set и ArrayList/LinkedList, HashMap/LinkedHashMap, HashSet соответственно). Желательно переписать эти исходники самостоятельно слово в слово.
- Делаешь задачи на оперирование данными (сортировка, фильтрация, добавление и удаление), замеряешь скорость работы в зависимости от выбора структуры данных. Для языков с библиотекой с поточной обработкой коллекций (stream, например, в Java и JavaScript) повторяешь все те же задачи с использованием этих библиотек.
- Пишешь первый pet project. Например, читаешь самую базовые документацию по какому-нибудь простому протоколу типа HTTP, пишешь простой веб-сервер с GET/POST на голых сокетах, открываешь страничку в браузере с собственного сервера - радуешься.
- Понимаешь, что счастливой жизни без версионирования нет - идешь учить git, заводишь себе GitHub. Учишь базовые команды git - status, add, commit, stash, checkout, push, pull, blame. Учишь интерфейс IDE или утилиты для работы с git - SourceTree, например.

##### Этап 2 - почти Junior
- Понимаешь, что ты не знаешь ничего. Идешь и читаешь многопоточность (синхронизацию, volatile, потокобезопасность, пулы, конкурентные структуры данных), I/O (ввод/вывод из stdin/stdout, файлов, сокетов и т.п.), работу с памятью или принципы работы GC (в зависимости от языка), лямбды (функциональные возможности языка), профилирование запущенных приложений (увидеть, как именно и зачем запущенное приложение утилизирует CPU, память и ввод-вывод).
- Переписываешь свой веб-сервер из pet project, чтобы он мог работать больше чем с одним запросом.
- Начинаешь учить какой-нибудь популярный фреймворк - быстро выясняешь, что ты ни разу не подключал ни одну зависимость и вообще собирал проект без понимания, что это и как работает. Начинаешь разбираться с зависимостями, репозиториями (Maven, npm, NuGet), версионированием (SemVer) и системами сборки.
- Разбираешься с зависимостями, переписываешь свой веб-сервер с готовыми библиотеками, оборачиваешь в систему сборки.
- Продолжаешь учить фреймворк. Разбирешься с IoC/DI (Inversion of Control/Dependency Injection), аннотациями в языке и рефлексией (при наличии). Разбираешься с логированием и параметризацией. Разбираешься со стеком для работы с REST.
- Пишешь заново веб-сервер с использованием DI контейнера и обработкой запросов средствами фреймворка.
- Понимаешь, что обычно на вход приходит не строка и не массив байт, а JSON или XML, а парсить ввод вручную, токенизируя строчки - путь в ад. Учишь спецификации JSON и XML, по верхам проходишь по JSON Schema и XSD/XSLT. Узнаешь про плагины для генерации объектов сериализации/десериализации.
- Добавляешь в сборку плагины для кодогенерации DTO из спецификаций.
- Продолжая разбираться с фреймворком, изучаешь разные развлечения вроде аспектов, реактивного программирования, асинхронной обработки задач.
- Пробуешь добавить все это в pet project, половину выбрасываешь по итогу.

##### Этап 3 - крепкий Junior
- Выясняешь, что данные хранить негде. Идешь читать про базы данных, протоколы работы с ними, SQL/NoSQL, удивляешься количеству, берешь первую попавшуюся (для начала реляционную). Разбираешься с persistence в своем языке, концепцией ORM, сериализацией/десериализацией и маппингом типов данных между БД и языком, транзакционностью и уровнями изоляции, нормализацией данных в структуры, работой с ключами (ID, primary key, foreign key) и каскадными связями (один к одному, один ко многим, многие к одному). Разбираешься с механизмами индексации данных, играешься с EXPLAIN и построениями планов запросов. Разбираешься с кэшированием и возможными уровнями.
- Разворачиваешь локально базу данных, пробуешь добавить в проект сохранение данных.
- Выясняешь, что существуют еще объектные базы данных (Mongo), различные key-value (Redis, memcached), графовые (Neo4J) и так далее.
- Пробуешь поиграться с ними, пробуешь шардирование и репликацию данных.
- Выясняешь, что приложению нужно взаимодействовать с внешним миром. Читаешь протоколы (REST, HTTP, Kafka и т.п.), открываешь для себя контракты веб-сервисов (OpenAPI/Swagger/RESTDocs), открываешь для себя очереди сообщений.
- Ставишь ActiveMQ или Kafka, разбираешься с очередями сообщений. Добавляешь документацию веб-сервиса в pet project.

##### Этап 4 - Middle
- Выясняешь, что твой pet project выглядит уже совсем плохо и надо все переделывать. Учишь рефакторинг, читаешь дядю Боба (Clean Code, Clean Coder), паттерны проектирования (GoF - Gang of four), принципы SOLID, концепты best practice и code smell, ставишь статический анализатор кода (SonarQube), снова начинаешь учиться кодить.
- Переписываешь свой pet project красиво.
- Задачи множатся и ширятся. Нужно где-то внятно записывать. Учишь Trello/Notion/JIRA, начинаешь трекать время (Toggl, например), ставишь себе эстимейты, не укладываешься, начинаешь расписывать все.
- Понимаешь, что нюансов в проекте уже много. Начинаешь документировать все, читаешь Markdown и ADoc, делаешь себе README.md.
- Понимаешь, что проект на соседней машине магически не работает и падает. Внесение изменений все ломает. Учишь тестирование кода, глушение зависимостей, поднятие тестового окружения, TDD и BDD.
- Понимаешь, что ничего из уже написанного внятно в тесты не обернуть. Снова начинаешь рефакторить. Бросаешь, пишешь заново по TDD, пробуешь добиться test coverage.
- Хочешь поставить свой pet project на сервер и не понимаешь, как. Идешь учить Linux, менеджеры пакетов, процессы, базовые syscall’ы, устройство системы инциализации (systemd), лимиты ядры (дескрипторы), файловые системы.
- Начинаешь разбираться в системном софте и bash. Пишешь скрипты на bash, ставишь сервисы в systemd, разбираешься с конфигами системного софта (например, с nginx).

##### Этап 5 - крепкий Middle
- Выясняешь, что есть безопасность. Нужно шифровать трафик и ограничивать доступ. Учишь ролевые модели, разбираешься с TLS (Диффи-Хеллман, удостоверяющие центры, цепочки подтверждений, электронная подпись). Учишь в своем фреймворке заведение ролей, создание сертификатов, мучаешься с self signed.
- Дописываешь конфигурируемую ролевую модель на свой сервис, добавляешь TLS.
- Начинаешь поддержку какого-нибудь проекта в production. Ловишь сотни странных багов.
- Учишься быть богом grep и tail вместе с regexp и прокачиваешь скилл оракула по переписке.
- Понимаешь, что регулярная сборка проекта начинает отнимать часы жизни. Изучаешь CI/CD, разбираешься с GitHub Actions/GitLab CI/Jenkins/Bamboo/TeamCity (на выбор).
- Поднимаешь себе pipeline сборки с регулярными прогонами тестов, статическим анализатором кода (баги, безопасность и code smell), сборкой релизов и выкладкой в репозиторий. Добавляешь pipeline для установки на сервер.

##### Этап 6 - Senior
- Понимаешь, что жить с зоопарком БД, очередями сообщений и прочим софтом прямо на машине нормально нельзя, к тому же это непереносимо. Учишь контейниризацию, начинаешь поднимать свой pet project на Docker, а окружение в Compose. Разбираешься с устройством контейнеров (UnionFS, cgroups, namespaces, SELinux) и премудростями для работы с ними (монтирование дисков, подключение к контейнеру, сеть, репозитории, базовые образы).
- Пишешь первый Dockerfile и docker-compose, упираешься в кучу странностей. Побеждаешь. Публикуешь первый артефакт в Docker Hub.
- Выясняешь, что монолит - не модно, а микросервисы - модно. Читаешь Мартина Фаулера. Начинаешь погружаться в архитектуру. Учишь концепцию The Twelve-Factor App.
- Дробишь свой проект на микросервисы, делая один большой распределенный монолит.
- Выясняешь, что Docker в голом виде все равно никакой, разбираешься с оркестрацией контейнеров (Kubernetes). Учишь конфигурацию выделения ресурсов и поднятия сервисов после падения.
- Начинаешь ставить все на готовый SaaS и кайфовать с красоты, ругаясь на странности и косяки.
- Понимаешь, что не представляешь, что теперь происходит в проекте. Изучаешь health check, трассировку запросов между сервисами, сбор событий.
- Добавляешь себе подсистему трассировки (Zipkin) и обработки логов (ELK).
- Для проекта нужны фронты. Учишься работать с HTML, CSS, JavaScript, npm, Yarn, SCSS/SASS, Autoprefixer, ECMAScript, Webassembly, Webpack, Browserify, nginx, Node.js, Express.js, AngularJS, React, Bootstrap, React Bootstrap, FontAwesome, CDN, TypeScript, V8, MEAN/MERN, MongoDB, событийно-ориентированным программированием, реактивным программированием, изучаешь проблему C10k/C10M…
- Пишешь фронты…


И так далее. Есть еще буквально несколько нюансов по дороге - поиск работы, конференции, выступления, хакатоны, управление командой, работа в коллективе, дедлайны, Agile/Scrum/Waterfall, сертификации по технологиям, прохождение собеседований, взаимодействие с тестировщиками/аналитиками/заказчиком/начальством, смена работы, знание рынка труда, Upwork, премудрости удаленки и еще от силы парочка десятков.

Возможно, я забыл что-нибудь по дороге... 

Но начать входить в IT можно с вышеуказанного. 